var t=Object.defineProperty,e=Object.defineProperties,s=Object.getOwnPropertyDescriptors,n=Object.getOwnPropertySymbols,r=Object.prototype.hasOwnProperty,o=Object.prototype.propertyIsEnumerable,i=(e,s,n)=>s in e?t(e,s,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[s]=n,a=(t,e)=>{for(var s in e||(e={}))r.call(e,s)&&i(t,s,e[s]);if(n)for(var s of n(e))o.call(e,s)&&i(t,s,e[s]);return t};import{V as c,af as l,av as p,aF as d,aG as u,aH as h,aI as f,aw as y,Z as m,ar as g,aJ as x,a9 as w,aK as b,E as P,M as B,a0 as A,a6 as M,aL as T,aM as S,a2 as v,aN as V,aO as F,aP as U,aQ as z,a1 as I,aR as k,aS as E,aT as C,aU as _,aV as O,x as j,B as D,am as H,l as q,aW as W,aX as G,aY as R}from"./app.fee60d13.js";const L=Math.pow(2,-24);class K{constructor(){}}function X(t,e,s){return s.min.x=e[t],s.min.y=e[t+1],s.min.z=e[t+2],s.max.x=e[t+3],s.max.y=e[t+4],s.max.z=e[t+5],s}function N(t){let e=-1,s=-1/0;for(let n=0;n<3;n++){const r=t[n+3]-t[n];r>s&&(s=r,e=n)}return e}function Z(t,e){e.set(t)}function Y(t,e,s){let n,r;for(let o=0;o<3;o++){const i=o+3;n=t[o],r=e[o],s[o]=n<r?n:r,n=t[i],r=e[i],s[i]=n>r?n:r}}function $(t,e,s){for(let n=0;n<3;n++){const r=e[t+2*n],o=e[t+2*n+1],i=r-o,a=r+o;i<s[n]&&(s[n]=i),a>s[n+3]&&(s[n+3]=a)}}function J(t){const e=t[3]-t[0],s=t[4]-t[1],n=t[5]-t[2];return 2*(e*s+s*n+n*e)}function Q(t,e,s,n,r=null){let o=1/0,i=1/0,a=1/0,c=-1/0,l=-1/0,p=-1/0,d=1/0,u=1/0,h=1/0,f=-1/0,y=-1/0,m=-1/0;const g=null!==r;for(let x=6*e,w=6*(e+s);x<w;x+=6){const e=t[x+0],s=t[x+1],n=e-s,r=e+s;n<o&&(o=n),r>c&&(c=r),g&&e<d&&(d=e),g&&e>f&&(f=e);const w=t[x+2],b=t[x+3],P=w-b,B=w+b;P<i&&(i=P),B>l&&(l=B),g&&w<u&&(u=w),g&&w>y&&(y=w);const A=t[x+4],M=t[x+5],T=A-M,S=A+M;T<a&&(a=T),S>p&&(p=S),g&&A<h&&(h=A),g&&A>m&&(m=A)}n[0]=o,n[1]=i,n[2]=a,n[3]=c,n[4]=l,n[5]=p,g&&(r[0]=d,r[1]=u,r[2]=h,r[3]=f,r[4]=y,r[5]=m)}const tt=(t,e)=>t.candidate-e.candidate,et=new Array(32).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),st=new Float32Array(6);function nt(t,e){function s(t){u&&u(t/h)}function n(e,r,u,h=null,y=0){if(!f&&y>=c&&(f=!0,l&&(console.warn(`MeshBVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`),console.warn(t))),u<=p||y>=c)return s(r+u),e.offset=r,e.count=u,e;const m=function(t,e,s,n,r,o){let i=-1,a=0;if(0===o)i=N(e),-1!==i&&(a=(e[i]+e[i+3])/2);else if(1===o)i=N(t),-1!==i&&(a=function(t,e,s,n){let r=0;for(let o=e,i=e+s;o<i;o++)r+=t[6*o+2*n];return r/s}(s,n,r,i));else if(2===o){const o=J(t);let c=1.25*r;const l=6*n,p=6*(n+r);for(let t=0;t<3;t++){const n=e[t],d=(e[t+3]-n)/32;if(r<8){const e=[...et];e.length=r;let n=0;for(let r=l;r<p;r+=6,n++){const o=e[n];o.candidate=s[r+2*t],o.count=0;const{bounds:i,leftCacheBounds:a,rightCacheBounds:c}=o;for(let t=0;t<3;t++)c[t]=1/0,c[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,i[t]=1/0,i[t+3]=-1/0;$(r,s,i)}e.sort(tt);let d=r;for(let t=0;t<d;t++){const s=e[t];for(;t+1<d&&e[t+1].candidate===s.candidate;)e.splice(t+1,1),d--}for(let r=l;r<p;r+=6){const n=s[r+2*t];for(let t=0;t<d;t++){const o=e[t];n>=o.candidate?$(r,s,o.rightCacheBounds):($(r,s,o.leftCacheBounds),o.count++)}}for(let s=0;s<d;s++){const n=e[s],l=n.count,p=r-n.count,d=n.leftCacheBounds,u=n.rightCacheBounds;let h=0;0!==l&&(h=J(d)/o);let f=0;0!==p&&(f=J(u)/o);const y=1+1.25*(h*l+f*p);y<c&&(i=t,c=y,a=n.candidate)}}else{for(let t=0;t<32;t++){const e=et[t];e.count=0,e.candidate=n+d+t*d;const s=e.bounds;for(let t=0;t<3;t++)s[t]=1/0,s[t+3]=-1/0}for(let r=l;r<p;r+=6){let e=~~((s[r+2*t]-n)/d);e>=32&&(e=31);const o=et[e];o.count++,$(r,s,o.bounds)}const e=et[31];Z(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){const e=et[t],s=et[t+1];Y(e.bounds,s.rightCacheBounds,e.rightCacheBounds)}let u=0;for(let s=0;s<31;s++){const e=et[s],n=e.count,l=e.bounds,p=et[s+1].rightCacheBounds;0!==n&&(0===u?Z(l,st):Y(l,st,st)),u+=n;let d=0,h=0;0!==u&&(d=J(st)/o);const f=r-u;0!==f&&(h=J(p)/o);const y=1+1.25*(d*u+h*f);y<c&&(i=t,c=y,a=e.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);return{axis:i,pos:a}}(e.boundingData,h,i,r,u,d);if(-1===m.axis)return s(r+u),e.offset=r,e.count=u,e;const g=function(t,e,s,n,r){let o=s,i=s+n-1;const a=r.pos,c=2*r.axis;for(;;){for(;o<=i&&e[6*o+c]<a;)o++;for(;o<=i&&e[6*i+c]>=a;)i--;if(!(o<i))return o;for(let s=0;s<3;s++){let n=t[3*o+s];t[3*o+s]=t[3*i+s],t[3*i+s]=n;let r=e[6*o+2*s+0];e[6*o+2*s+0]=e[6*i+2*s+0],e[6*i+2*s+0]=r;let a=e[6*o+2*s+1];e[6*o+2*s+1]=e[6*i+2*s+1],e[6*i+2*s+1]=a}o++,i--}}(a,i,r,u,m);if(g===r||g===r+u)s(r+u),e.offset=r,e.count=u;else{e.splitAxis=m.axis;const t=new K,s=r,a=g-r;e.left=t,t.boundingData=new Float32Array(6),Q(i,s,a,t.boundingData,o),n(t,s,a,o,y+1);const c=new K,l=g,p=u-a;e.right=c,c.boundingData=new Float32Array(6),Q(i,l,p,c.boundingData,o),n(c,l,p,o,y+1)}return e}!function(t,e){if(!t.index){const s=t.attributes.position.count,n=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let r;r=s>65535?new Uint32Array(new n(4*s)):new Uint16Array(new n(2*s)),t.setIndex(new x(r,1));for(let t=0;t<s;t++)r[t]=t}}(t,e);const r=new Float32Array(6),o=new Float32Array(6),i=function(t,e){const s=t.attributes.position,n=s.array,r=t.index.array,o=r.length/3,i=new Float32Array(6*o),a=s.offset||0;let c=3;s.isInterleavedBufferAttribute&&(c=s.data.stride);for(let l=0;l<o;l++){const t=3*l,s=6*l,o=r[t+0]*c+a,p=r[t+1]*c+a,d=r[t+2]*c+a;for(let r=0;r<3;r++){const t=n[o+r],a=n[p+r],c=n[d+r];let l=t;a<l&&(l=a),c<l&&(l=c);let u=t;a>u&&(u=a),c>u&&(u=c);const h=(u-l)/2,f=2*r;i[s+f+0]=l+h,i[s+f+1]=h+(Math.abs(l)+h)*L,l<e[r]&&(e[r]=l),u>e[r+3]&&(e[r+3]=u)}}return i}(t,r),a=t.index.array,c=e.maxDepth,l=e.verbose,p=e.maxLeafTris,d=e.strategy,u=e.onProgress,h=t.index.count/3;let f=!1;const y=[],m=function(t){if(!t.groups||!t.groups.length)return[{offset:0,count:t.index.count/3}];const e=[],s=new Set;for(const r of t.groups)s.add(r.start),s.add(r.start+r.count);const n=Array.from(s.values()).sort(((t,e)=>t-e));for(let r=0;r<n.length-1;r++){const t=n[r],s=n[r+1];e.push({offset:t/3,count:(s-t)/3})}return e}(t);if(1===m.length){const t=m[0],e=new K;e.boundingData=r,function(t,e,s,n){let r=1/0,o=1/0,i=1/0,a=-1/0,c=-1/0,l=-1/0;for(let p=6*e,d=6*(e+s);p<d;p+=6){const e=t[p+0];e<r&&(r=e),e>a&&(a=e);const s=t[p+2];s<o&&(o=s),s>c&&(c=s);const n=t[p+4];n<i&&(i=n),n>l&&(l=n)}n[0]=r,n[1]=o,n[2]=i,n[3]=a,n[4]=c,n[5]=l}(i,t.offset,t.count,o),n(e,t.offset,t.count,o),y.push(e)}else for(let g of m){const t=new K;t.boundingData=new Float32Array(6),Q(i,g.offset,g.count,t.boundingData,o),n(t,g.offset,g.count,o),y.push(t)}return y}class rt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,n=-1/0;for(let r=0,o=t.length;r<o;r++){const o=t[r][e];s=o<s?o:s,n=o>n?o:n}this.min=s,this.max=n}setFromPoints(t,e){let s=1/0,n=-1/0;for(let r=0,o=e.length;r<o;r++){const o=e[r],i=t.dot(o);s=i<s?i:s,n=i>n?i:n}this.min=s,this.max=n}isSeparated(t){return this.min>t.max||t.min>this.max}}rt.prototype.setFromBox=function(){const t=new c;return function(e,s){const n=s.min,r=s.max;let o=1/0,i=-1/0;for(let a=0;a<=1;a++)for(let s=0;s<=1;s++)for(let c=0;c<=1;c++){t.x=n.x*a+r.x*(1-a),t.y=n.y*s+r.y*(1-s),t.z=n.z*c+r.z*(1-c);const l=e.dot(t);o=Math.min(l,o),i=Math.max(l,i)}this.min=o,this.max=i}}(),function(){const t=new rt}();const ot=function(){const t=new c,e=new c,s=new c;return function(n,r,o){const i=n.start,a=t,c=r.start,l=e;s.subVectors(i,c),t.subVectors(n.end,r.start),e.subVectors(r.end,r.start);const p=s.dot(l),d=l.dot(a),u=l.dot(l),h=s.dot(a),f=a.dot(a)*u-d*d;let y,m;y=0!==f?(p*d-h*u)/f:0,m=(p+y*d)/u,o.x=y,o.y=m}}(),it=function(){const t=new l,e=new c,s=new c;return function(n,r,o,i){ot(n,r,t);let a=t.x,c=t.y;if(a>=0&&a<=1&&c>=0&&c<=1)return n.at(a,o),void r.at(c,i);if(a>=0&&a<=1)return c<0?r.at(0,i):r.at(1,i),void n.closestPointToPoint(i,!0,o);if(c>=0&&c<=1)return a<0?n.at(0,o):n.at(1,o),void r.closestPointToPoint(o,!0,i);{let t,l;t=a<0?n.start:n.end,l=c<0?r.start:r.end;const p=e,d=s;return n.closestPointToPoint(l,!0,e),r.closestPointToPoint(t,!0,s),p.distanceToSquared(l)<=d.distanceToSquared(t)?(o.copy(p),void i.copy(l)):(o.copy(t),void i.copy(d))}}}(),at=function(){const t=new c,e=new c,s=new p,n=new d;return function(r,o){const{radius:i,center:a}=r,{a:c,b:l,c:p}=o;n.start=c,n.end=l;if(n.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;n.start=c,n.end=p;if(n.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;n.start=l,n.end=p;if(n.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;const d=o.getPlane(s);if(Math.abs(d.distanceToPoint(a))<=i){const t=d.projectPoint(a,e);if(o.containsPoint(t))return!0}return!1}}();class ct extends u{constructor(...t){super(...t),this.isSeparatingAxisTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new c)),this.satBounds=new Array(4).fill().map((()=>new rt)),this.points=[this.a,this.b,this.c],this.sphere=new h,this.plane=new p,this.needsUpdate=!1}intersectsSphere(t){return at(t,this)}update(){const t=this.a,e=this.b,s=this.c,n=this.points,r=this.satAxes,o=this.satBounds,i=r[0],a=o[0];this.getNormal(i),a.setFromPoints(i,n);const c=r[1],l=o[1];c.subVectors(t,e),l.setFromPoints(c,n);const p=r[2],d=o[2];p.subVectors(e,s),d.setFromPoints(p,n);const u=r[3],h=o[3];u.subVectors(s,t),h.setFromPoints(u,n),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(i,t),this.needsUpdate=!1}}ct.prototype.closestPointToSegment=function(){const t=new c,e=new c,s=new d;return function(n,r=null,o=null){const{start:i,end:a}=n,c=this.points;let l,p=1/0;for(let d=0;d<3;d++){const i=(d+1)%3;s.start.copy(c[d]),s.end.copy(c[i]),it(s,n,t,e),l=t.distanceToSquared(e),l<p&&(p=l,r&&r.copy(t),o&&o.copy(e))}return this.closestPointToPoint(i,t),l=i.distanceToSquared(t),l<p&&(p=l,r&&r.copy(t),o&&o.copy(i)),this.closestPointToPoint(a,t),l=a.distanceToSquared(t),l<p&&(p=l,r&&r.copy(t),o&&o.copy(a)),Math.sqrt(p)}}(),ct.prototype.intersectsTriangle=function(){const t=new ct,e=new Array(3),s=new Array(3),n=new rt,r=new rt,o=new c,i=new c,a=new c,l=new c,p=new d,u=new d,h=new d;return function(c,d=null){this.needsUpdate&&this.update(),c.isSeparatingAxisTriangle?c.needsUpdate&&c.update():(t.copy(c),t.update(),c=t);const f=this.satBounds,y=this.satAxes;s[0]=c.a,s[1]=c.b,s[2]=c.c;for(let t=0;t<4;t++){const e=f[t],r=y[t];if(n.setFromPoints(r,s),e.isSeparated(n))return!1}const m=c.satBounds,g=c.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let t=0;t<4;t++){const s=m[t],r=g[t];if(n.setFromPoints(r,e),s.isSeparated(n))return!1}for(let t=0;t<4;t++){const i=y[t];for(let t=0;t<4;t++){const a=g[t];if(o.crossVectors(i,a),n.setFromPoints(o,e),r.setFromPoints(o,s),n.isSeparated(r))return!1}}if(d){const t=this.plane,e=c.plane;if(Math.abs(t.normal.dot(e.normal))>1-1e-10)console.warn("SeparatingAxisTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),d.start.set(0,0,0),d.end.set(0,0,0);else{const s=this.points;let n=!1;for(let t=0;t<3;t++){const r=s[t],o=s[(t+1)%3];if(p.start.copy(r),p.end.copy(o),e.intersectLine(p,n?u.start:u.end)){if(n)break;n=!0}}const r=c.points;let o=!1;for(let e=0;e<3;e++){const s=r[e],n=r[(e+1)%3];if(p.start.copy(s),p.end.copy(n),t.intersectLine(p,o?h.start:h.end)){if(o)break;o=!0}}if(u.delta(i),h.delta(a),i.dot(a)<0){let t=h.start;h.start=h.end,h.end=t}l.subVectors(u.start,h.start),l.dot(i)>0?d.start.copy(u.start):d.start.copy(h.start),l.subVectors(u.end,h.end),l.dot(i)<0?d.end.copy(u.end):d.end.copy(h.end)}}return!0}}(),ct.prototype.distanceToPoint=function(){const t=new c;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),ct.prototype.distanceToTriangle=function(){const t=new c,e=new c,s=["a","b","c"],n=new d,r=new d;return function(o,i=null,a=null){const c=i||a?n:null;if(this.intersectsTriangle(o,c))return(i||a)&&(i&&c.getCenter(i),a&&c.getCenter(a)),0;let l=1/0;for(let e=0;e<3;e++){let n;const r=s[e],c=o[r];this.closestPointToPoint(c,t),n=c.distanceToSquared(t),n<l&&(l=n,i&&i.copy(t),a&&a.copy(c));const p=this[r];o.closestPointToPoint(p,t),n=p.distanceToSquared(t),n<l&&(l=n,i&&i.copy(p),a&&a.copy(t))}for(let p=0;p<3;p++){const c=s[p],d=s[(p+1)%3];n.set(this[c],this[d]);for(let p=0;p<3;p++){const c=s[p],d=s[(p+1)%3];r.set(o[c],o[d]),it(n,r,t,e);const u=t.distanceToSquared(e);u<l&&(l=u,i&&i.copy(t),a&&a.copy(e))}}return Math.sqrt(l)}}();class lt extends f{constructor(...t){super(...t),this.isOrientedBox=!0,this.matrix=new y,this.invMatrix=new y,this.points=new Array(8).fill().map((()=>new c)),this.satAxes=new Array(3).fill().map((()=>new c)),this.satBounds=new Array(3).fill().map((()=>new rt)),this.alignedSatBounds=new Array(3).fill().map((()=>new rt)),this.needsUpdate=!1}set(t,e,s){super.set(t,e),this.matrix=s,this.needsUpdate=!0}copy(t){super.copy(t),this.matrix.copy(t.matrix),this.needsUpdate=!0}}lt.prototype.update=function(){const t=this.matrix,e=this.min,s=this.max,n=this.points;for(let c=0;c<=1;c++)for(let r=0;r<=1;r++)for(let o=0;o<=1;o++){const i=n[1*c|2*r|4*o];i.x=c?s.x:e.x,i.y=r?s.y:e.y,i.z=o?s.z:e.z,i.applyMatrix4(t)}const r=this.satBounds,o=this.satAxes,i=n[0];for(let c=0;c<3;c++){const t=o[c],e=r[c],s=n[1<<c];t.subVectors(i,s),e.setFromPoints(t,n)}const a=this.alignedSatBounds;a[0].setFromPointsField(n,"x"),a[1].setFromPointsField(n,"y"),a[2].setFromPointsField(n,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},lt.prototype.intersectsBox=function(){const t=new rt;return function(e){this.needsUpdate&&this.update();const s=e.min,n=e.max,r=this.satBounds,o=this.satAxes,i=this.alignedSatBounds;if(t.min=s.x,t.max=n.x,i[0].isSeparated(t))return!1;if(t.min=s.y,t.max=n.y,i[1].isSeparated(t))return!1;if(t.min=s.z,t.max=n.z,i[2].isSeparated(t))return!1;for(let a=0;a<3;a++){const s=o[a],n=r[a];if(t.setFromBox(s,e),n.isSeparated(t))return!1}return!0}}(),lt.prototype.intersectsTriangle=function(){const t=new ct,e=new Array(3),s=new rt,n=new rt,r=new c;return function(o){this.needsUpdate&&this.update(),o.isSeparatingAxisTriangle?o.needsUpdate&&o.update():(t.copy(o),t.update(),o=t);const i=this.satBounds,a=this.satAxes;e[0]=o.a,e[1]=o.b,e[2]=o.c;for(let t=0;t<3;t++){const n=i[t],r=a[t];if(s.setFromPoints(r,e),n.isSeparated(s))return!1}const c=o.satBounds,l=o.satAxes,p=this.points;for(let t=0;t<3;t++){const e=c[t],n=l[t];if(s.setFromPoints(n,p),e.isSeparated(s))return!1}for(let t=0;t<3;t++){const o=a[t];for(let t=0;t<4;t++){const i=l[t];if(r.crossVectors(o,i),s.setFromPoints(r,e),n.setFromPoints(r,p),s.isSeparated(n))return!1}}return!0}}(),lt.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},lt.prototype.distanceToPoint=function(){const t=new c;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),lt.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new d)),s=new Array(12).fill().map((()=>new d)),n=new c,r=new c;return function(o,i=0,a=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(a||c)&&(o.getCenter(r),this.closestPointToPoint(r,n),o.closestPointToPoint(n,r),a&&a.copy(n),c&&c.copy(r)),0;const l=i*i,p=o.min,d=o.max,u=this.points;let h=1/0;for(let t=0;t<8;t++){const e=u[t];r.copy(e).clamp(p,d);const s=e.distanceToSquared(r);if(s<h&&(h=s,a&&a.copy(e),c&&c.copy(r),s<l))return Math.sqrt(s)}let f=0;for(let n=0;n<3;n++)for(let r=0;r<=1;r++)for(let o=0;o<=1;o++){const i=(n+1)%3,a=(n+2)%3,c=1<<n|r<<i|o<<a,l=u[r<<i|o<<a],h=u[c];e[f].set(l,h);const y=t[n],m=t[i],g=t[a],x=s[f],w=x.start,b=x.end;w[y]=p[y],w[m]=r?p[m]:d[m],w[g]=o?p[g]:d[m],b[y]=d[y],b[m]=r?p[m]:d[m],b[g]=o?p[g]:d[m],f++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let s=0;s<=1;s++){r.x=t?d.x:p.x,r.y=e?d.y:p.y,r.z=s?d.z:p.z,this.closestPointToPoint(r,n);const o=r.distanceToSquared(n);if(o<h&&(h=o,a&&a.copy(n),c&&c.copy(r),o<l))return Math.sqrt(o)}for(let t=0;t<12;t++){const o=e[t];for(let t=0;t<12;t++){const e=s[t];it(o,e,n,r);const i=n.distanceToSquared(r);if(i<h&&(h=i,a&&a.copy(n),c&&c.copy(r),i<l))return Math.sqrt(i)}}return Math.sqrt(h)}}();const pt=new c,dt=new c,ut=new c,ht=new l,ft=new l,yt=new l,mt=new c;function gt(t,e,s,n,r,o,i){pt.fromBufferAttribute(e,n),dt.fromBufferAttribute(e,r),ut.fromBufferAttribute(e,o);const a=function(t,e,s,n,r,o){let i;return i=o===D?t.intersectTriangle(n,s,e,!0,r):t.intersectTriangle(e,s,n,o!==H,r),null===i?null:{distance:t.origin.distanceTo(r),point:r.clone()}}(t,pt,dt,ut,mt,i);if(a){s&&(ht.fromBufferAttribute(s,n),ft.fromBufferAttribute(s,r),yt.fromBufferAttribute(s,o),a.uv=u.getUV(mt,pt,dt,ut,ht,ft,yt,new l));const t={a:n,b:r,c:o,normal:new c,materialIndex:0};u.getNormal(pt,dt,ut,t.normal),a.face=t,a.faceIndex=n}return a}function xt(t,e,s,n,r){const o=3*n,i=t.index.getX(o),a=t.index.getX(o+1),c=t.index.getX(o+2),l=gt(s,t.attributes.position,t.attributes.uv,i,a,c,e);return l?(l.faceIndex=n,r&&r.push(l),l):null}function wt(t,e,s){return null===t?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(s.ray.origin),t.object=e,t.distance<s.near||t.distance>s.far?null:t)}function bt(t,e,s,n){const r=t.a,o=t.b,i=t.c;let a=e,c=e+1,l=e+2;s&&(a=s.getX(e),c=s.getX(e+1),l=s.getX(e+2)),r.x=n.getX(a),r.y=n.getY(a),r.z=n.getZ(a),o.x=n.getX(c),o.y=n.getY(c),o.z=n.getZ(c),i.x=n.getX(l),i.y=n.getY(l),i.z=n.getZ(l)}function Pt(t,e,s,n,r,o,i){const a=s.index,c=s.attributes.position;for(let l=t,p=e+t;l<p;l++)if(bt(i,3*l,a,c),i.needsUpdate=!0,n(i,l,r,o))return!0;return!1}class Bt{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function At(t,e){return 65535===e[t+15]}function Mt(t,e){return e[t+6]}function Tt(t,e){return e[t+14]}function St(t){return t+8}function vt(t,e){return e[t+6]}const Vt=new f,Ft=new c,Ut=["x","y","z"];function zt(t,e,s,n,r){let o=2*t,i=jt,a=Dt,c=Ht;if(At(o,a)){!function(t,e,s,n,r,o){for(let i=n,a=n+r;i<a;i++)xt(t,e,s,i,o)}(e,s,n,Mt(t,c),Tt(o,a),r)}else{const o=St(t);Ct(o,i,n,Ft)&&zt(o,e,s,n,r);const a=vt(t,c);Ct(a,i,n,Ft)&&zt(a,e,s,n,r)}}function It(t,e,s,n){let r=2*t,o=jt,i=Dt,a=Ht;if(At(r,i)){return function(t,e,s,n,r){let o=1/0,i=null;for(let a=n,c=n+r;a<c;a++){const n=xt(t,e,s,a);n&&n.distance<o&&(i=n,o=n.distance)}return i}(e,s,n,Mt(t,a),Tt(r,i))}{const r=function(t,e){return e[t+7]}(t,a),i=Ut[r],c=n.direction[i]>=0;let l,p;c?(l=St(t),p=vt(t,a)):(l=vt(t,a),p=St(t));const d=Ct(l,o,n,Ft)?It(l,e,s,n):null;if(d){const t=d.point[i];if(c?t<=o[p+r]:t>=o[p+r+3])return d}const u=Ct(p,o,n,Ft)?It(p,e,s,n):null;return d&&u?d.distance<=u.distance?d:u:d||u||null}}const kt=function(){let t,e;const s=[],n=new Bt((()=>new f));return function(...o){t=n.getPrimitive(),e=n.getPrimitive(),s.push(t,e);const i=r(...o);n.releasePrimitive(t),n.releasePrimitive(e),s.pop(),s.pop();const a=s.length;return a>0&&(e=s[a-1],t=s[a-2]),i};function r(s,n,o,i,a=null,c=0,l=0){function p(t){let e=2*t,s=Dt,n=Ht;for(;!At(e,s);)e=2*(t=St(t));return Mt(t,n)}function d(t){let e=2*t,s=Dt,n=Ht;for(;!At(e,s);)e=2*(t=vt(t,n));return Mt(t,n)+Tt(e,s)}let u=2*s,h=jt,f=Dt,y=Ht;if(At(u,f)){const e=Mt(s,y),n=Tt(u,f);return X(s,h,t),i(e,n,!1,l,c+s,t)}{const u=St(s),m=vt(s,y);let g,x,w,b,P=u,B=m;if(a&&(w=t,b=e,X(P,h,w),X(B,h,b),g=a(w),x=a(b),x<g)){P=m,B=u;const t=g;g=x,x=t,w=b}w||(w=t,X(P,h,w));const A=o(w,At(2*P,f),g,l+1,c+P);let M;if(2===A){const t=p(P);M=i(t,d(P)-t,!0,l+1,c+P,w)}else M=A&&r(P,n,o,i,a,c,l+1);if(M)return!0;b=e,X(B,h,b);const T=o(b,At(2*B,f),x,l+1,c+B);let S;if(2===T){const t=p(B);S=i(t,d(B)-t,!0,l+1,c+B,b)}else S=T&&r(B,n,o,i,a,c,l+1);return!!S}}}(),Et=function(){const t=new ct,e=new ct,s=new y,n=new lt,r=new lt;return function o(i,a,c,l,p=null){let d=2*i,u=jt,h=Dt,f=Ht;null===p&&(c.boundingBox||c.computeBoundingBox(),n.set(c.boundingBox.min,c.boundingBox.max,l),p=n);if(!At(d,h)){const t=i+8,e=f[i+6];X(t,u,Vt);if(p.intersectsBox(Vt)&&o(t,a,c,l,p))return!0;X(e,u,Vt);return!!(p.intersectsBox(Vt)&&o(e,a,c,l,p))}{const n=a,o=n.index,p=n.attributes.position,y=c.index,m=c.attributes.position,g=Mt(i,f),x=Tt(d,h);if(s.copy(l).invert(),c.boundsTree){X(i,u,r),r.matrix.copy(s),r.needsUpdate=!0;return c.boundsTree.shapecast({intersectsBounds:t=>r.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(l),t.b.applyMatrix4(l),t.c.applyMatrix4(l),t.needsUpdate=!0;for(let s=3*g,n=3*(x+g);s<n;s+=3)if(bt(e,s,o,p),e.needsUpdate=!0,t.intersectsTriangle(e))return!0;return!1}})}for(let r=3*g,i=x+3*g;r<i;r+=3){bt(t,r,o,p),t.a.applyMatrix4(s),t.b.applyMatrix4(s),t.c.applyMatrix4(s),t.needsUpdate=!0;for(let s=0,n=y.count;s<n;s+=3)if(bt(e,s,y,m),e.needsUpdate=!0,t.intersectsTriangle(e))return!0}}}}();function Ct(t,e,s,n){return X(t,e,Vt),s.intersectBox(Vt,n)}const _t=[];let Ot,jt,Dt,Ht;function qt(t){Ot&&_t.push(Ot),Ot=t,jt=new Float32Array(t),Dt=new Uint16Array(t),Ht=new Uint32Array(t)}function Wt(){Ot=null,jt=null,Dt=null,Ht=null,_t.length&&qt(_t.pop())}const Gt=Symbol("skip tree generation"),Rt=new f,Lt=new f,Kt=new y,Xt=new lt,Nt=new lt,Zt=new c,Yt=new c,$t=new c,Jt=new c,Qt=new c,te=new f,ee=new Bt((()=>new ct));class se{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),se.serialize(arguments[0],{cloneBuffers:void 0===arguments[2]||arguments[2]});e=a({cloneBuffers:!0},e);const s=t.geometry,n=t._roots,r=s.getIndex();let o;return o=e.cloneBuffers?{roots:n.map((t=>t.slice())),index:r.array.slice()}:{roots:n,index:r.array},o}static deserialize(t,n,r={}){if("boolean"==typeof r)return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),se.deserialize(arguments[0],arguments[1],{setIndex:void 0===arguments[2]||arguments[2]});r=a({setIndex:!0},r);const{index:o,roots:i}=t,c=new se(n,(l=a({},r),e(l,s({[Gt]:!0}))));var l;if(c._roots=i,r.setIndex){const e=n.getIndex();if(null===e){const e=new x(t.index,1,!1);n.setIndex(e)}else e.array!==o&&(e.array.set(o),e.needsUpdate=!0)}return c}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign({strategy:0,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[Gt]:!1},e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[Gt]||(this._roots=function(t,e){const s=nt(t,e);let n,r,o;const i=[],a=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let p=0;p<s.length;p++){const t=s[p],e=new a(32*c(t));n=new Float32Array(e),r=new Uint32Array(e),o=new Uint16Array(e),l(0,t),i.push(e)}return i;function c(t){return t.count?1:1+c(t.left)+c(t.right)}function l(t,e){const s=t/4,i=t/2,a=!!e.count,c=e.boundingData;for(let r=0;r<6;r++)n[s+r]=c[r];if(a){const n=e.offset,a=e.count;return r[s+6]=n,o[i+14]=a,o[i+15]=65535,t+32}{const n=e.left,o=e.right,i=e.splitAxis;let a;if(a=l(t+32,n),a/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return r[s+6]=a/4,a=l(a,o),r[s+7]=i,a}}}(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new f))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,s=e.index.array,n=e.attributes.position,r=n.array,o=n.offset||0;let i,a,c,l,p=3;n.isInterleavedBufferAttribute&&(p=n.data.stride);let d=0;const u=this._roots;for(let f=0,y=u.length;f<y;f++)i=u[f],a=new Uint32Array(i),c=new Uint16Array(i),l=new Float32Array(i),h(0,d),d+=i.byteLength;function h(e,n,i=!1){const d=2*e;if(65535===c[d+15]){const t=a[e+6];let n=1/0,i=1/0,u=1/0,h=-1/0,f=-1/0,y=-1/0;for(let e=3*t,a=3*(t+c[d+14]);e<a;e++){const t=s[e]*p+o,a=r[t+0],c=r[t+1],l=r[t+2];a<n&&(n=a),a>h&&(h=a),c<i&&(i=c),c>f&&(f=c),l<u&&(u=l),l>y&&(y=l)}return(l[e+0]!==n||l[e+1]!==i||l[e+2]!==u||l[e+3]!==h||l[e+4]!==f||l[e+5]!==y)&&(l[e+0]=n,l[e+1]=i,l[e+2]=u,l[e+3]=h,l[e+4]=f,l[e+5]=y,!0)}{const s=e+8,r=a[e+6],o=s+n,c=r+n;let p=i,d=!1,u=!1;t?p||(d=t.has(o),u=t.has(c),p=!d&&!u):(d=!0,u=!0);const f=p||u;let y=!1;(p||d)&&(y=h(s,n,p));let m=!1;f&&(m=h(r,n,p));const g=y||m;if(g)for(let t=0;t<3;t++){const n=s+t,o=r+t,i=l[n],a=l[n+3],c=l[o],p=l[o+3];l[e+t]=i<c?i:c,l[e+t+3]=a>p?a:p}return g}}}traverse(t,e=0){const s=this._roots[e],n=new Uint32Array(s),r=new Uint16Array(s);!function e(o,i=0){const a=2*o,c=65535===r[a+15];if(c){const e=n[o+6],l=r[a+14];t(i,c,new Float32Array(s,4*o,6),e,l)}else{const r=o+8,a=n[o+6],l=n[o+7];t(i,c,new Float32Array(s,4*o,6),l)||(e(r,i+1),e(a,i+1))}}(0)}raycast(t,e=j){const s=this._roots,n=this.geometry,r=[],o=e.isMaterial,i=Array.isArray(e),a=n.groups,c=o?e.side:e;for(let l=0,p=s.length;l<p;l++){const o=i?e[a[l].materialIndex].side:c,p=r.length;if(qt(s[l]),zt(0,n,o,t,r),Wt(),i){const t=a[l].materialIndex;for(let e=p,s=r.length;e<s;e++)r[e].face.materialIndex=t}}return r}raycastFirst(t,e=j){const s=this._roots,n=this.geometry,r=e.isMaterial,o=Array.isArray(e);let i=null;const a=n.groups,c=r?e.side:e;for(let l=0,p=s.length;l<p;l++){const r=o?e[a[l].materialIndex].side:c;qt(s[l]);const p=It(0,n,r,t);Wt(),null!=p&&(null==i||p.distance<i.distance)&&(i=p,o&&(p.face.materialIndex=a[l].materialIndex))}return i}intersectsGeometry(t,e){const s=this.geometry;let n=!1;for(const r of this._roots)if(qt(r),n=Et(0,s,t,e),Wt(),n)break;return n}shapecast(t,e,s){const n=this.geometry;if(t instanceof Function){if(e){const t=e;e=(e,s,n,r)=>{const o=3*s;return t(e,o,o+1,o+2,n,r)}}t={boundsTraverseOrder:s,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const r=ee.getPrimitive();let{boundsTraverseOrder:o,intersectsBounds:i,intersectsRange:a,intersectsTriangle:c}=t;if(a&&c){const t=a;a=(e,s,o,i,a)=>!!t(e,s,o,i,a)||Pt(e,s,n,c,o,i,r)}else a||(a=c?(t,e,s,o)=>Pt(t,e,n,c,s,o,r):(t,e,s)=>s);let l=!1,p=0;for(const d of this._roots){if(qt(d),l=kt(0,n,i,a,o,p),Wt(),l)break;p+=d.byteLength}return ee.releasePrimitive(r),l}bvhcast(t,e,s){let{intersectsRanges:n,intersectsTriangles:r}=s;const o=this.geometry.index,i=this.geometry.attributes.position,a=t.geometry.index,c=t.geometry.attributes.position;Kt.copy(e).invert();const l=ee.getPrimitive(),p=ee.getPrimitive();if(r){let t=function(t,s,n,d,u,h,f,y){for(let m=n,g=n+d;m<g;m++){bt(p,3*m,a,c),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let e=t,n=t+s;e<n;e++)if(bt(l,3*e,o,i),l.needsUpdate=!0,r(l,p,e,m,u,h,f,y))return!0}return!1};if(n){const e=n;n=function(s,n,r,o,i,a,c,l){return!!e(s,n,r,o,i,a,c,l)||t(s,n,r,o,i,a,c,l)}}else n=t}this.getBoundingBox(Lt),Lt.applyMatrix4(e);const d=this.shapecast({intersectsBounds:t=>Lt.intersectsBox(t),intersectsRange:(e,s,r,o,i,a)=>(Rt.copy(a),Rt.applyMatrix4(Kt),t.shapecast({intersectsBounds:t=>Rt.intersectsBox(t),intersectsRange:(t,r,a,c,l)=>n(e,s,t,r,o,i,c,l)}))});return ee.releasePrimitive(l),ee.releasePrimitive(p),d}intersectsBox(t,e){return Xt.set(t.min,t.max,e),Xt.needsUpdate=!0,this.shapecast({intersectsBounds:t=>Xt.intersectsBox(t),intersectsTriangle:t=>Xt.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},n={},r=0,o=1/0){t.boundingBox||t.computeBoundingBox(),Xt.set(t.boundingBox.min,t.boundingBox.max,e),Xt.needsUpdate=!0;const i=this.geometry,a=i.attributes.position,c=i.index,l=t.attributes.position,p=t.index,d=ee.getPrimitive(),u=ee.getPrimitive();let h=Yt,f=$t,y=null,m=null;n&&(y=Jt,m=Qt);let g=1/0,x=null,w=null;return Kt.copy(e).invert(),Nt.matrix.copy(Kt),this.shapecast({boundsTraverseOrder:t=>Xt.distanceToBox(t,Math.min(g,o)),intersectsBounds:(t,e,s)=>s<g&&s<o&&(e&&(Nt.min.copy(t.min),Nt.max.copy(t.max),Nt.needsUpdate=!0),!0),intersectsRange:(s,n)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:t=>Nt.distanceToBox(t,Math.min(g,o)),intersectsBounds:(t,e,s)=>s<g&&s<o,intersectsRange:(t,o)=>{for(let i=3*t,b=3*(t+o);i<b;i+=3){bt(u,i,p,l),u.a.applyMatrix4(e),u.b.applyMatrix4(e),u.c.applyMatrix4(e),u.needsUpdate=!0;for(let t=3*s,e=3*(s+n);t<e;t+=3){bt(d,t,c,a),d.needsUpdate=!0;const e=d.distanceToTriangle(u,h,y);if(e<g&&(f.copy(h),m&&m.copy(y),g=e,x=t/3,w=i/3),e<r)return!0}}}});for(let t=0,o=p?p.count:l.count;t<o;t+=3){bt(u,t,p,l),u.a.applyMatrix4(e),u.b.applyMatrix4(e),u.c.applyMatrix4(e),u.needsUpdate=!0;for(let e=3*s,o=3*(s+n);e<o;e+=3){bt(d,e,c,a),d.needsUpdate=!0;const s=d.distanceToTriangle(u,h,y);if(s<g&&(f.copy(h),m&&m.copy(y),g=s,x=e/3,w=t/3),s<r)return!0}}}}),ee.releasePrimitive(d),ee.releasePrimitive(u),g===1/0?null:(s.point?s.point.copy(f):s.point=f.clone(),s.distance=g,s.faceIndex=x,n&&(n.point?n.point.copy(m):n.point=m.clone(),n.point.applyMatrix4(Kt),f.applyMatrix4(Kt),n.distance=f.sub(n.point).length(),n.faceIndex=w),s)}closestPointToPoint(t,e={},s=0,n=1/0){const r=s*s,o=n*n;let i=1/0,a=null;if(this.shapecast({boundsTraverseOrder:e=>(Zt.copy(t).clamp(e.min,e.max),Zt.distanceToSquared(t)),intersectsBounds:(t,e,s)=>s<i&&s<o,intersectsTriangle:(e,s)=>{e.closestPointToPoint(t,Zt);const n=t.distanceToSquared(Zt);return n<i&&(Yt.copy(Zt),i=n,a=s),n<r}}),i===1/0)return null;const c=Math.sqrt(i);return e.point?e.point.copy(Yt):e.point=Yt.clone(),e.distance=c,e.faceIndex=a,e}getBoundingBox(t){t.makeEmpty();return this._roots.forEach((e=>{X(0,new Float32Array(e),te),t.union(te)})),t}}const ne=se.prototype.raycast;se.prototype.raycast=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycast" has changed. See docs for new signature.');const[e,s,n,r]=t;return ne.call(this,n,e.material).forEach((t=>{(t=wt(t,e,s))&&r.push(t)})),r}return ne.apply(this,t)};const re=se.prototype.raycastFirst;se.prototype.raycastFirst=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycastFirst" has changed. See docs for new signature.');const[e,s,n]=t;return wt(re.call(this,n,e.material),e,s)}return re.apply(this,t)};const oe=se.prototype.closestPointToPoint;se.prototype.closestPointToPoint=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "closestPointToPoint" has changed. See docs for new signature.'),t.unshift();const e=t[1],s={};return t[1]=s,oe.apply(this,t),e&&e.copy(s.point),s.distance}return oe.apply(this,t)};const ie=se.prototype.closestPointToGeometry;se.prototype.closestPointToGeometry=function(...t){const e=t[2],s=t[3];if(e&&e.isVector3||s&&s.isVector3){console.warn('MeshBVH: The function signature and results frame for "closestPointToGeometry" has changed. See docs for new signature.');const n={},r={},o=t[1];return t[2]=n,t[3]=r,ie.apply(this,t),e&&e.copy(n.point),s&&s.copy(r.point).applyMatrix4(o),n.distance}return ie.apply(this,t)};const ae=se.prototype.refit;se.prototype.refit=function(...t){const e=t[0],s=t[1];if(s&&(s instanceof Set||Array.isArray(s))){console.warn('MeshBVH: The function signature for "refit" has changed. See docs for new signature.');const t=new Set;s.forEach((e=>t.add(e))),e&&e.forEach((e=>t.add(e))),ae.call(this,t)}else ae.apply(this,t)},["intersectsGeometry","shapecast","intersectsBox","intersectsSphere"].forEach((t=>{const e=se.prototype[t];se.prototype[t]=function(...s){return(null===s[0]||s[0].isMesh)&&(s.shift(),console.warn(`MeshBVH: The function signature for "${t}" has changed and no longer takes Mesh. See docs for new signature.`)),e.apply(this,s)}}));const ce=new f;class le extends m{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(t,e,s=10,n=0){super(),this.material=e,this.geometry=new g,this.name="MeshBVHRootVisualizer",this.depth=s,this.displayParents=!1,this.mesh=t,this.displayEdges=!0,this._group=n}raycast(){}update(){const t=this.geometry,e=this.mesh.geometry.boundsTree,s=this._group;if(t.dispose(),this.visible=!1,e){const n=this.depth-1,r=this.displayParents;let o=0;e.traverse(((t,e)=>{if(t===n||e)return o++,!0;r&&o++}),s);let i=0;const a=new Float32Array(24*o);let c,l;e.traverse(((t,e,s)=>{const o=t===n||e;if(o||r){X(0,s,ce);const{min:t,max:e}=ce;for(let s=-1;s<=1;s+=2){const n=s<0?t.x:e.x;for(let s=-1;s<=1;s+=2){const r=s<0?t.y:e.y;for(let s=-1;s<=1;s+=2){const o=s<0?t.z:e.z;a[i+0]=n,a[i+1]=r,a[i+2]=o,i+=3}}}return o}}),s),l=this.displayEdges?new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),c=a.length>65535?new Uint32Array(l.length*o):new Uint16Array(l.length*o);const p=l.length;for(let t=0;t<o;t++){const e=8*t,s=t*p;for(let t=0;t<p;t++)c[s+t]=e+l[t]}t.setIndex(new x(c,1,!1)),t.setAttribute("position",new x(a,3,!1)),this.visible=!0}}}class pe extends w{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t,this.meshMaterial.opacity=t}constructor(t,e=10){super(),this.name="MeshBVHVisualizer",this.depth=e,this.mesh=t,this.displayParents=!1,this.displayEdges=!0,this._roots=[];const s=new b({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),n=new P({color:65416,transparent:!0,opacity:.3,depthWrite:!1});n.color=s.color,this.edgeMaterial=s,this.meshMaterial=n,this.update()}update(){const t=this.mesh.geometry.boundsTree,e=t?t._roots.length:0;for(;this._roots.length>e;)this._roots.pop();for(let s=0;s<e;s++){if(s>=this._roots.length){const t=new le(this.mesh,this.edgeMaterial,this.depth,s);this.add(t),this._roots.push(t)}const t=this._roots[s];t.depth=this.depth,t.mesh=this.mesh,t.displayParents=this.displayParents,t.displayEdges=this.displayEdges,t.material=this.displayEdges?this.edgeMaterial:this.meshMaterial,t.update()}}updateMatrixWorld(...t){this.position.copy(this.mesh.position),this.rotation.copy(this.mesh.rotation),this.scale.copy(this.mesh.scale),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh}clone(){return new pe(this.mesh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const t=this.children;for(let e=0,s=t.length;e<s;e++)t[e].geometry.dispose()}}B.prototype.raycast;class de{constructor(t){this.collider=null,this.visualizer=null,this.player=null,this.controls=t.controls,this.object=null,this.environment=null,this.scene=t.scene,this.camera=t.camera,this.animate=t.animate,this.object=t.object,this.runCallback=t.runCallback,this.playerIsOnGround=!1,this.fwdPressed=!1,this.bkdPressed=!1,this.lftPressed=!1,this.rgtPressed=!1,this.playerVelocity=new c,this.upVector=new c(0,1,0),this.tempVector=new c,this.tempVector2=new c,this.tempBox=new f,this.tempMat=new y,this.tempSegment=new d,this.clock=new q,this.isRun=!1,this.angle=0,this.params={firstPerson:!1,displayCollider:!1,displayBVH:!1,visualizeDepth:10,gravity:-2,playerSpeed:.3,physicsSteps:12,playerVelocity:5,reset:this.reset}}init(){this.loadColliderEnvironment(),this.windowEvent(),this.animate.push((()=>{this.render()}))}loadColliderEnvironment(){(new f).setFromObject(this.scene),this.scene.updateMatrixWorld(!0);const t={};this.scene.traverse((e=>{if(e.isMesh&&void 0!==e.material.color){const s=e.material.color.getHex();t[s]=t[s]||[],t[s].push(e)}})),this.environment=new w;for(const n in t){const e=t[n],s=[];if(e.forEach((t=>{if(t.material.emissive)this.environment.attach(t);else{const e=t.geometry.clone();console.log(e),e.applyMatrix4(t.matrixWorld),!e.attributes.uv2&&e.index&&s.push(e)}})),s.length>0){const t=W(s),e=new B(t,new G({color:parseInt(n)}));e.material.transparent=!0,e.material.opacity=0,e.name="mool",this.environment.add(e)}}const e=[];this.environment.updateMatrixWorld(!0),this.environment.traverse((t=>{if(t.geometry){const s=t.geometry.clone();s.applyMatrix4(t.matrixWorld);for(const t in s.attributes)"position"!==t&&s.deleteAttribute(t);e.push(s)}}));const s=W(e,!1);s.boundsTree=new se(s,{lazyGeneration:!1}),this.collider=new B(s),this.collider.material.wireframe=!0,this.collider.material.opacity=.5,this.collider.material.transparent=!0,this.visualizer=new pe(this.collider,this.params.visualizeDepth),this.scene.add(this.visualizer),this.scene.add(this.collider),this.scene.add(this.environment),this.loadplayer()}loadplayer(){this.player=new B(new R(.5,5.5,.5,17,.5),new G),this.player.geometry.translate(0,-.5,0),this.player.capsuleInfo={radius:.7,segment:new d(new c,new c(0,-1,0))},this.player.name="player",this.player.castShadow=!0,this.player.receiveShadow=!0,this.player.material.shadowSide=2,this.player.visible=!1,console.log(this.object),this.scene.add(this.player,this.object),this.reset()}windowEvent(){const t=this;document.addEventListener("keydown",(function(e){switch(e.code){case"KeyW":t.fwdPressed=!0;break;case"KeyS":t.bkdPressed=!0;break;case"KeyD":t.rgtPressed=!0;break;case"KeyA":t.lftPressed=!0;break;case"KeyZ":t.playerIsOnGround&&(t.playerVelocity.y=t.params.playerVelocity);break;case"ShiftLeft":t.params.playerSpeed=.6,t.params.playerVelocity=7;break;case"KeyV":t.params.firstPerson=!t.params.firstPerson,t.params.firstPerson?(t.camera.updateMatrixWorld(),t.object.visible=!1,t.controls.reset()):(t.camera.position.sub(t.controls.target).normalize().multiplyScalar(5).add(t.controls.target),t.camera.updateMatrixWorld(),t.object.visible=!0)}t.isRun||(t.isRun=!0,t.runCallback instanceof Function&&t.runCallback(!0))})),document.addEventListener("keyup",(function(e){switch(e.code){case"KeyW":t.fwdPressed=!1;break;case"KeyS":t.bkdPressed=!1;break;case"KeyD":t.rgtPressed=!1;break;case"KeyA":t.lftPressed=!1;break;case"ShiftLeft":t.params.playerSpeed=.3,t.params.playerVelocity=5}!t.isRun||t.fwdPressed||t.bkdPressed||t.rgtPressed||t.lftPressed||(t.isRun=!1,t.runCallback instanceof Function&&t.runCallback(!1))}))}reset(){this.playerVelocity.set(0,0,0),this.player.position.set(0,80,50),this.camera.position.sub(this.controls.target),this.controls.target.copy(this.player.position),this.camera.position.add(this.player.position),this.controls.update()}render(){const t=Math.min(this.clock.getDelta(),.1);if((this.rgtPressed||this.lftPressed||this.bkdPressed||this.fwdPressed)&&this.params.firstPerson,this.params.firstPerson?(this.controls.maxPolarAngle=Math.PI/2,this.controls.minDistance=1e-4,this.controls.maxDistance=.001):(this.controls.maxPolarAngle=Math.PI/2,this.controls.minDistance=4,this.controls.maxDistance=10),this.collider&&this.player){this.collider.visible=this.params.displayCollider,this.visualizer.visible=this.params.displayBVH;const e=this.params.physicsSteps;for(let s=0;s<e;s++)this.updatePlayer(t)}}updatePlayer(t){this.playerVelocity.y+=this.playerIsOnGround?0:t*this.params.gravity,this.player.position.addScaledVector(this.playerVelocity,t);const e=this.controls.getAzimuthalAngle();this.fwdPressed&&(this.tempVector.set(0,0,-1).applyAxisAngle(this.upVector,this.angle+e),this.player.position.addScaledVector(this.tempVector,this.params.playerSpeed*t)),this.bkdPressed&&(this.tempVector.set(0,0,1).applyAxisAngle(this.upVector,e),this.player.position.addScaledVector(this.tempVector,this.params.playerSpeed*t)),this.lftPressed&&(this.tempVector.set(-1,0,0).applyAxisAngle(this.upVector,e),this.player.position.addScaledVector(this.tempVector,this.params.playerSpeed*t)),this.rgtPressed&&(this.tempVector.set(1,0,0).applyAxisAngle(this.upVector,e),this.player.position.addScaledVector(this.tempVector,this.params.playerSpeed*t)),this.player.updateMatrixWorld();const s=this.player.capsuleInfo;this.tempBox.makeEmpty(),this.tempMat.copy(this.collider.matrixWorld).invert(),this.tempSegment.copy(s.segment),this.tempSegment.start.applyMatrix4(this.player.matrixWorld).applyMatrix4(this.tempMat),this.tempSegment.end.applyMatrix4(this.player.matrixWorld).applyMatrix4(this.tempMat),this.tempBox.expandByPoint(this.tempSegment.start),this.tempBox.expandByPoint(this.tempSegment.end),this.tempBox.min.addScalar(-s.radius),this.tempBox.max.addScalar(s.radius),this.collider.geometry.boundsTree.shapecast({intersectsBounds:t=>t.intersectsBox(this.tempBox),intersectsTriangle:t=>{const e=this.tempVector,n=this.tempVector2,r=t.closestPointToSegment(this.tempSegment,e,n);if(r<s.radius){const t=s.radius-r,o=n.sub(e).normalize();this.tempSegment.start.addScaledVector(o,t),this.tempSegment.end.addScaledVector(o,t)}}});const n=this.tempVector;n.copy(this.tempSegment.start).applyMatrix4(this.collider.matrixWorld);const r=this.tempVector2;r.subVectors(n,this.player.position),this.playerIsOnGround=r.y>Math.abs(t*this.playerVelocity.y*.25);const o=Math.max(0,r.length()-1e-5);r.normalize().multiplyScalar(o),this.player.position.add(r),this.playerIsOnGround?this.playerVelocity.set(0,0,0):(r.normalize(),this.playerVelocity.addScaledVector(r,-r.dot(this.playerVelocity))),this.camera.position.sub(this.controls.target),this.controls.target.copy(this.player.position),this.camera.position.add(this.player.position),this.camera.updateMatrixWorld();let i=this.player.position.clone();this.controls.position0.copy(i.addScaledVector(new c(0,0,1).applyAxisAngle(this.upVector,e),.01)),this.controls.target0.copy(this.player.position),this.player.rotation.y=this.controls.getAzimuthalAngle()+3+this.angle,this.object&&(this.object.rotation.y=this.controls.getAzimuthalAngle()+3+this.angle,this.object.position.set(this.player.position.clone().x,this.player.position.clone().y,this.player.position.clone().z),this.object.position.y-=1.5),this.player.position.y<-25&&this.reset()}}export{de as R};
